import os
import sys
import subprocess
import logging
from pathlib import Path
from setuptools import setup, find_packages

def setup_logging():
    """Configura sistema de logging"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    return logging.getLogger(__name__)

logger = setup_logging()

def print_banner():
    """Exibe banner de in√≠cio"""
    print("=" * 70)
    print("üöÄ SETUP DO SISTEMA EXTRATOR DE COMPROVANTES PIX")
    print("   Sistema completo com OCR + ML + YOLO + Flask")
    print("=" * 70)

def check_python_version():
    """Verifica vers√£o do Python"""
    if sys.version_info < (3, 8):
        print("‚ùå Python 3.8+ √© necess√°rio!")
        print(f"   Vers√£o atual: {sys.version}")
        return False
    print(f"‚úÖ Python {sys.version_info.major}.{sys.version_info.minor} detectado")
    return True

def setup_virtual_environment():
    """Verifica e configura ambiente virtual"""
    try:
        # Verifica se j√° est√° em um ambiente virtual
        in_venv = (
            hasattr(sys, 'real_prefix') or 
            (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix)
        )
        
        if in_venv:
            print("‚úÖ Ambiente virtual detectado")
            return True
        else:
            print("‚ö†Ô∏è  ATEN√á√ÉO: Execute este script em um ambiente virtual!")
            print("\nüìã Para criar e ativar um ambiente virtual:")
            print("   python -m venv venv")
            print("   venv\\Scripts\\activate     # Windows")
            print("   source venv/bin/activate  # Linux/Mac")
            print("\n   Depois execute novamente: python setup.py")
            return False
    except Exception as e:
        logger.error(f"Erro na verifica√ß√£o do ambiente: {e}")
        return False

def create_directories():
    """Cria estrutura de diret√≥rios necess√°ria"""
    print("\nüìÅ Criando estrutura de diret√≥rios...")
    
    directories = [
        'data/raw/exemplos/imagens',
        'data/processed',
        'uploads',
        'models',
        'logs',
        'src/core',
        'src/ml',
        'src/web/templates',
        'src/web/static/css',
        'src/web/static/js',
        'src/web/static/images',
        'tests',
        'docs',
        'temp'
    ]
    
    created_count = 0
    for directory in directories:
        try:
            Path(directory).mkdir(parents=True, exist_ok=True)
            print(f"  ‚úÖ {directory}")
            created_count += 1
        except Exception as e:
            print(f"  ‚ùå Erro ao criar {directory}: {e}")
    
    print(f"\nüìä {created_count}/{len(directories)} diret√≥rios criados com sucesso")
    return created_count == len(directories)

def install_requirements():
    """Instala depend√™ncias Python com fallbacks"""
    print("\nüì¶ Instalando depend√™ncias Python...")
    
    if not os.path.exists('requirements.txt'):
        print("  ‚ùå Arquivo requirements.txt n√£o encontrado!")
        return False
    
    try:
        # Atualiza pip, setuptools e wheel primeiro
        print("  üîÑ Atualizando ferramentas b√°sicas...")
        subprocess.check_call([
            sys.executable, '-m', 'pip', 'install', '--upgrade', 
            'pip', 'setuptools', 'wheel'
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Tenta instala√ß√£o normal primeiro
        print("  üîÑ Instalando depend√™ncias...")
        try:
            subprocess.check_call([
                sys.executable, '-m', 'pip', 'install', '-r', 'requirements.txt'
            ], timeout=600)  # 10 minutos timeout
            print("  ‚úÖ Depend√™ncias instaladas com sucesso")
            return True
            
        except subprocess.CalledProcessError:
            print("  ‚ö†Ô∏è  Falha na instala√ß√£o normal. Tentando instala√ß√£o individual...")
            return install_packages_individually()
        
    except subprocess.CalledProcessError as e:
        print(f"  ‚ùå Erro na atualiza√ß√£o das ferramentas: {e}")
        print("     Tentando instala√ß√£o individual...")
        return install_packages_individually()

def install_packages_individually():
    """Instala pacotes individualmente para identificar problemas"""
    print("  üîÑ Instala√ß√£o individual de pacotes...")
    
    # Pacotes essenciais primeiro
    essential_packages = [
        'numpy>=1.24.0',
        'Pillow>=10.0.0',
        'opencv-python>=4.8.0',
        'Flask>=3.0.0',
        'pytesseract>=0.3.10',
        'scikit-learn>=1.3.0',
        'pandas>=2.0.0'
    ]
    
    # Pacotes opcionais
    optional_packages = [
        'torch>=2.0.0',
        'torchvision>=0.15.0',
        'ultralytics>=8.0.0',
        'easyocr>=1.7.0'
    ]
    
    success_count = 0
    
    # Instala pacotes essenciais
    for package in essential_packages:
        if install_single_package(package, essential=True):
            success_count += 1
    
    # Instala pacotes opcionais
    for package in optional_packages:
        install_single_package(package, essential=False)
    
    # Instala depend√™ncias restantes
    remaining_packages = [
        'flask-cors', 'regex', 'fuzzywuzzy', 'python-levenshtein',
        'requests', 'werkzeug', 'python-dotenv', 'jinja2', 'joblib'
    ]
    
    for package in remaining_packages:
        install_single_package(package, essential=False)
    
    print(f"  üìä {success_count}/{len(essential_packages)} pacotes essenciais instalados")
    return success_count >= len(essential_packages) - 1

def install_single_package(package, essential=True):
    """Instala um pacote individual"""
    try:
        print(f"    üîÑ Instalando {package}...")
        subprocess.check_call([
            sys.executable, '-m', 'pip', 'install', package
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=120)
        print(f"    ‚úÖ {package}")
        return True
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
        if essential:
            print(f"    ‚ùå {package} (essencial)")
        else:
            print(f"    ‚ö†Ô∏è  {package} (opcional)")
        return False

def check_system_dependencies():
    """Verifica depend√™ncias do sistema"""
    print("\nüîç Verificando depend√™ncias do sistema...")
    
    # Verifica Tesseract
    tesseract_ok = check_tesseract()
    
    # Verifica Microsoft Visual C++
    vc_ok = check_visual_cpp()
    
    return tesseract_ok

def check_tesseract():
    """Verifica instala√ß√£o do Tesseract"""
    try:
        result = subprocess.run(['tesseract', '--version'], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            version = result.stdout.split('\n')[0]
            print(f"  ‚úÖ Tesseract OCR encontrado: {version}")
            return True
        else:
            print("  ‚ö†Ô∏è  Tesseract n√£o encontrado")
            print_tesseract_install_instructions()
            return False
    except (subprocess.TimeoutExpired, FileNotFoundError):
        print("  ‚ö†Ô∏è  Tesseract OCR n√£o encontrado")
        print_tesseract_install_instructions()
        return False

def check_visual_cpp():
    """Verifica Microsoft Visual C++ (Windows)"""
    if sys.platform == "win32":
        try:
            import winreg
            # Verifica registros do Visual C++
            key_paths = [
                r"SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x64",
                r"SOFTWARE\WOW6432Node\Microsoft\VisualStudio\14.0\VC\Runtimes\x64"
            ]
            
            for path in key_paths:
                try:
                    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, path):
                        print("  ‚úÖ Microsoft Visual C++ Redistributable encontrado")
                        return True
                except WindowsError:
                    continue
            
            print("  ‚ö†Ô∏è  Microsoft Visual C++ Redistributable pode estar faltando")
            print("     Baixe de: https://aka.ms/vs/17/release/vc_redist.x64.exe")
            return False
            
        except ImportError:
            return True  # N√£o consegue verificar, assume OK
    
    return True  # Linux/Mac n√£o precisa

def print_tesseract_install_instructions():
    """Exibe instru√ß√µes de instala√ß√£o do Tesseract"""
    print("     üìã INSTRU√á√ïES DE INSTALA√á√ÉO DO TESSERACT:")
    print("     Windows:")
    print("       1. Baixe: https://github.com/UB-Mannheim/tesseract/wiki")
    print("       2. Instale o execut√°vel")
    print("       3. Adicione ao PATH: C:\\Program Files\\Tesseract-OCR")
    print("     Ubuntu/Debian:")
    print("       sudo apt update")
    print("       sudo apt install tesseract-ocr tesseract-ocr-por")
    print("     macOS:")
    print("       brew install tesseract tesseract-lang")

def run_basic_tests():
    """Executa testes b√°sicos de importa√ß√£o"""
    print("\nüß™ Executando testes b√°sicos...")
    
    tests = [
        ('numpy', 'NumPy'),
        ('PIL', 'Pillow'),
        ('cv2', 'OpenCV'),
        ('flask', 'Flask'),
        ('pytesseract', 'Tesseract Python'),
        ('sklearn', 'Scikit-learn'),
        ('pandas', 'Pandas')
    ]
    
    success_count = 0
    for module, name in tests:
        try:
            __import__(module)
            print(f"  ‚úÖ {name}")
            success_count += 1
        except ImportError as e:
            print(f"  ‚ùå {name} - Erro: {str(e)[:50]}...")
    
    # Testes opcionais
    optional_tests = [
        ('easyocr', 'EasyOCR'),
        ('ultralytics', 'YOLO'),
        ('torch', 'PyTorch'),
        ('torchvision', 'TorchVision')
    ]
    
    optional_success = 0
    for module, name in optional_tests:
        try:
            __import__(module)
            print(f"  ‚úÖ {name} (opcional)")
            optional_success += 1
        except ImportError:
            print(f"  ‚ö†Ô∏è  {name} (opcional) - n√£o dispon√≠vel")
    
    print(f"\nüìä {success_count}/{len(tests)} depend√™ncias principais OK")
    print(f"üìä {optional_success}/{len(optional_tests)} depend√™ncias opcionais OK")
    
    return success_count >= len(tests) - 2  # Permite 2 falhas

def create_installation_report():
    """Cria relat√≥rio de instala√ß√£o"""
    print("\nüìã Criando relat√≥rio de instala√ß√£o...")
    
    try:
        import json
        from datetime import datetime
        
        report = {
            "installation_date": datetime.now().isoformat(),
            "python_version": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
            "platform": sys.platform,
            "virtual_env": bool(getattr(sys, 'base_prefix', sys.prefix) != sys.prefix),
            "installed_packages": [],
            "failed_packages": [],
            "system_dependencies": {
                "tesseract": check_tesseract_simple(),
                "visual_cpp": check_visual_cpp() if sys.platform == "win32" else "N/A"
            }
        }
        
        # Testa pacotes importantes
        test_packages = [
            'numpy', 'opencv-python', 'flask', 'pytesseract', 
            'scikit-learn', 'pandas', 'torch', 'ultralytics', 'easyocr'
        ]
        
        for package in test_packages:
            try:
                __import__(package.replace('-', '_'))
                report["installed_packages"].append(package)
            except ImportError:
                report["failed_packages"].append(package)
        
        with open('installation_report.json', 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print("  ‚úÖ Relat√≥rio salvo em: installation_report.json")
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erro ao criar relat√≥rio: {e}")
        return False

def check_tesseract_simple():
    """Verifica√ß√£o simples do Tesseract"""
    try:
        result = subprocess.run(['tesseract', '--version'], 
                              capture_output=True, text=True, timeout=5)
        return result.returncode == 0
    except:
        return False

def download_yolo_model():
    """Baixa modelo YOLO se necess√°rio"""
    print("\nü§ñ Configurando modelo YOLO...")
    
    try:
        from ultralytics import YOLO
        
        # Tenta carregar o modelo (baixa automaticamente se n√£o existir)
        print("  üîÑ Baixando YOLOv8...")
        model = YOLO('yolov8n.pt')
        
        # Salva no diret√≥rio de modelos
        model_path = Path('models/yolov8n.pt')
        if not model_path.exists():
            # Move o modelo para o diret√≥rio correto
            import shutil
            yolo_cache = Path.home() / '.cache' / 'ultralytics'
            if (yolo_cache / 'yolov8n.pt').exists():
                shutil.copy2(yolo_cache / 'yolov8n.pt', model_path)
        
        print("  ‚úÖ Modelo YOLO configurado")
        return True
        
    except Exception as e:
        print(f"  ‚ö†Ô∏è  Aviso: Erro ao configurar YOLO: {e}")
        print("     O modelo ser√° baixado automaticamente no primeiro uso")
        return False

def create_env_file():
    """Cria arquivo de configura√ß√£o .env"""
    print("\n‚öôÔ∏è  Criando arquivo de configura√ß√£o...")
    
    env_content = """# Configura√ß√µes do Sistema Extrator de Comprovantes Pix
# Flask Configura√ß√µes
FLASK_ENV=development
FLASK_DEBUG=True
FLASK_HOST=0.0.0.0
FLASK_PORT=5000

# Upload Configura√ß√µes
UPLOAD_FOLDER=uploads
MAX_FILE_SIZE=16777216
ALLOWED_EXTENSIONS=png,jpg,jpeg,gif,bmp,tiff

# OCR Configura√ß√µes
TESSERACT_CMD=tesseract
OCR_LANGUAGE=por
OCR_CONFIG=--oem 3 --psm 6

# ML Configura√ß√µes
MODEL_PATH=models/
CONFIDENCE_THRESHOLD=0.7
ML_ENABLED=True

# YOLO Configura√ß√µes
YOLO_MODEL=yolov8n.pt
YOLO_CONFIDENCE=0.5
YOLO_ENABLED=True

# Logging
LOG_LEVEL=INFO
LOG_FILE=logs/app.log

# Processamento
BATCH_SIZE=10
PARALLEL_PROCESSING=True
TEMP_DIR=temp

# Cache
CACHE_ENABLED=True
CACHE_TTL=3600
"""
    
    try:
        with open('.env', 'w', encoding='utf-8') as f:
            f.write(env_content)
        print("  ‚úÖ Arquivo .env criado")
        return True
    except Exception as e:
        print(f"  ‚ùå Erro ao criar .env: {e}")
        return False

def create_gitignore():
    """Cria arquivo .gitignore"""
    print("\nüìù Criando arquivo .gitignore...")
    
    gitignore_content = """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual Environment
venv/
env/
ENV/
.venv/

# IDE
.vscode/
.idea/
*.swp
*.swo
.spyderproject
.spyproject

# Sistema
.DS_Store
Thumbs.db
desktop.ini

# Logs
logs/
*.log

# Uploads e arquivos tempor√°rios
uploads/
temp/
temp_*
*.tmp

# Modelos treinados
models/*.pkl
models/*.pth
models/*.h5
models/*.model

# Dados sens√≠veis
.env
.env.local
config.local.py
secrets.py

# Cache
.cache/
.pytest_cache/
__pycache__/

# Jupyter
.ipynb_checkpoints/
*.ipynb

# Dados de teste grandes
data/raw/exemplos/imagens/*.jpg
data/raw/exemplos/imagens/*.png
data/raw/exemplos/imagens/*.jpeg

# Backup
*.bak
*.backup

# Coverage
.coverage
htmlcov/

# Profiling
*.prof
"""
    
    try:
        with open('.gitignore', 'w', encoding='utf-8') as f:
            f.write(gitignore_content)
        print("  ‚úÖ Arquivo .gitignore criado")
        return True
    except Exception as e:
        print(f"  ‚ùå Erro ao criar .gitignore: {e}")
        return False

def run_basic_tests():
    """Executa testes b√°sicos de importa√ß√£o"""
    print("\nüß™ Executando testes b√°sicos...")
    
    tests = [
        ('cv2', 'OpenCV'),
        ('numpy', 'NumPy'),
        ('PIL', 'Pillow'),
        ('pytesseract', 'Tesseract Python'),
        ('flask', 'Flask'),
        ('sklearn', 'Scikit-learn'),
        ('pandas', 'Pandas')
    ]
    
    success_count = 0
    for module, name in tests:
        try:
            __import__(module)
            print(f"  ‚úÖ {name}")
            success_count += 1
        except ImportError:
            print(f"  ‚ùå {name} - n√£o importado")
    
    # Testes opcionais
    optional_tests = [
        ('easyocr', 'YOLO'),
        ('ultralytics', 'YOLO'),
        ('torch', 'PyTorch')
    ]
    
    for module, name in optional_tests:
        try:
            __import__(module)
            print(f"  ‚úÖ {name} (opcional)")
        except ImportError:
            print(f"  ‚ö†Ô∏è  {name} (opcional) - n√£o dispon√≠vel")
    
    print(f"\nüìä {success_count}/{len(tests)} depend√™ncias principais OK")
    return success_count >= len(tests) - 1  # Permite 1 falha

def create_sample_files():
    """Cria arquivos de exemplo"""
    print("\nüìã Criando arquivos de exemplo...")
    
    try:
        # Cria arquivo de exemplo para teste
        sample_config = {
            "name": "Sistema Extrator de Comprovantes Pix",
            "version": "1.0.0",
            "status": "Configurado com sucesso",
            "components": {
                "ocr": "Tesseract + EasyOCR",
                "ml": "Scikit-learn",
                "detection": "YOLOv8",
                "web": "Flask"
            }
        }
        
        import json
        with open('config.json', 'w', encoding='utf-8') as f:
            json.dump(sample_config, f, indent=2, ensure_ascii=False)
        
        print("  ‚úÖ Arquivo config.json criado")
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erro ao criar arquivos: {e}")
        return False

def create_run_script():
    """Cria script de execu√ß√£o"""
    print("\nüöÄ Criando script de execu√ß√£o...")
    
    # Script para Windows
    run_bat = """@echo off
echo Iniciando Sistema Extrator de Comprovantes Pix...
echo.

if not exist venv (
    echo Ambiente virtual nao encontrado!
    echo Execute: python -m venv venv
    pause
    exit /b 1
)

call venv\\Scripts\\activate
python src\\web\\app.py
pause
"""
    
    # Script para Linux/Mac
    run_sh = """#!/bin/bash
echo "Iniciando Sistema Extrator de Comprovantes Pix..."
echo

if [ ! -d "venv" ]; then
    echo "Ambiente virtual n√£o encontrado!"
    echo "Execute: python -m venv venv"
    exit 1
fi

source venv/bin/activate
python src/web/app.py
"""
    
    try:
        with open('run.bat', 'w', encoding='utf-8') as f:
            f.write(run_bat)
        
        with open('run.sh', 'w', encoding='utf-8') as f:
            f.write(run_sh)
        
        # Torna o script execut√°vel no Linux/Mac
        import stat
        os.chmod('run.sh', stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)
        
        print("  ‚úÖ Scripts de execu√ß√£o criados (run.bat, run.sh)")
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erro ao criar scripts: {e}")
        return False

def display_final_instructions():
    """Exibe instru√ß√µes finais"""
    print("\n" + "=" * 70)
    print("üéâ SETUP CONCLU√çDO COM SUCESSO!")
    print("=" * 70)
    print("\nüìã PR√ìXIMOS PASSOS:")
    print("1. üìÅ Coloque imagens de comprovantes em: data/raw/exemplos/imagens/")
    print("2. üöÄ Execute o sistema:")
    print("   Windows: run.bat")
    print("   Linux/Mac: ./run.sh")
    print("   Ou manualmente: python src/web/app.py")
    print("\n3. üåê Acesse: http://localhost:5000")
    print("\nüìö FUNCIONALIDADES:")
    print("‚Ä¢ üì§ Upload de comprovantes via interface web")
    print("‚Ä¢ ü§ñ Chatbot para an√°lise interativa")
    print("‚Ä¢ üîç OCR avan√ßado (Tesseract + EasyOCR)")
    print("‚Ä¢ üéØ Detec√ß√£o inteligente com YOLO")
    print("‚Ä¢ üß† Machine Learning para melhor precis√£o")
    print("‚Ä¢ üìä Processamento em lote")
    print("\n‚öôÔ∏è  CONFIGURA√á√ÉO:")
    print("‚Ä¢ Edite .env para personalizar configura√ß√µes")
    print("‚Ä¢ Logs em: logs/app.log")
    print("‚Ä¢ Modelos em: models/")
    print("\nüÜò SUPORTE:")
    print("‚Ä¢ Verifique logs em caso de erro")
    print("‚Ä¢ Certifique-se que Tesseract est√° instalado")
    print("‚Ä¢ Para d√∫vidas, consulte a documenta√ß√£o")
    print("\n" + "=" * 70)

def main():
    """Fun√ß√£o principal do setup"""
    print_banner()
    
    # Lista de verifica√ß√µes atualizadas
    checks = [
        ("Verificando Python", check_python_version),
        ("Verificando ambiente virtual", setup_virtual_environment),
        ("Criando diret√≥rios", create_directories),
        ("Verificando depend√™ncias do sistema", check_system_dependencies),
        ("Instalando depend√™ncias Python", install_requirements),
        ("Configurando YOLO", download_yolo_model),
        ("Criando arquivo .env", create_env_file),
        ("Criando .gitignore", create_gitignore),
        ("Executando testes b√°sicos", run_basic_tests),
        ("Criando arquivos de exemplo", create_sample_files),
        ("Criando scripts de execu√ß√£o", create_run_script),
        ("Gerando relat√≥rio de instala√ß√£o", create_installation_report)
    ]
    
    success_count = 0
    total_checks = len(checks)
    
    for i, (description, check_func) in enumerate(checks, 1):
        print(f"\n[{i}/{total_checks}] {description}...")
        try:
            if check_func():
                success_count += 1
        except Exception as e:
            logger.error(f"Erro em '{description}': {e}")
    
    print(f"\nüìä RESULTADO: {success_count}/{total_checks} verifica√ß√µes conclu√≠das")
    
    if success_count >= total_checks - 3:  # Permite 3 falhas
        display_final_instructions()
        print("\nüí° DICA: Verifique installation_report.json para detalhes da instala√ß√£o")
        return True
    else:
        print("\n‚ùå Setup incompleto. Verifique os erros acima e:")
        print("   1. Instale o Tesseract OCR se necess√°rio")
        print("   2. Execute: pip install --upgrade pip setuptools wheel")
        print("   3. Tente: pip install -r requirements.txt")
        print("   4. Verifique installation_report.json para detalhes")
        return False

if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Setup interrompido pelo usu√°rio.")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Erro fatal no setup: {e}")
        sys.exit(1)

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

with open("requirements.txt", "r", encoding="utf-8") as fh:
    requirements = [line.strip() for line in fh if line.strip() and not line.startswith("#")]

setup(
    name="extrator-comprovantes-pix",
    version="1.0.0",
    author="David Damasceno",
    author_email="davidamascen07@gmail.com",
    description="Sistema inteligente de extra√ß√£o de dados de comprovantes PIX usando OCR e ML",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/Davidamascen07/TCC2",
    packages=find_packages(),
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Topic :: Scientific/Engineering :: Image Recognition",
        "Topic :: Office/Business :: Financial",
        "Topic :: Software Development :: Libraries :: Python Modules",
    ],
    python_requires=">=3.8",
    install_requires=requirements,
    extras_require={
        "dev": [
            "pytest>=6.0",
            "pytest-cov>=2.0",
            "black>=21.0",
            "flake8>=3.8",
            "mypy>=0.812",
        ],
        "gpu": [
            "torch[cuda]>=2.2.0",
            "torchvision[cuda]>=0.17.0",
        ],
    },
    entry_points={
        "console_scripts": [
            "extrator-pix=main:main",
        ],
    },
    package_data={
        "": ["*.txt", "*.md", "*.yml", "*.yaml"],
    },
    include_package_data=True,
    zip_safe=False,
)
